<examples>
    <overview>
        Complete workflow examples demonstrating how the branch generator mode operates
        in different scenarios, from simple cases to complex multi-feature situations.
    </overview>

    <example name="simple_two_feature_split">
        <scenario>
            User has been working on a feature branch and made commits for two different features
            that should be split into separate PRs.
        </scenario>

        <initial_state>
            <current_branch>feature/mixed-work</current_branch>
            <commits>
                <commit hash="abc1234">feat: add user login form</commit>
                <commit hash="def5678">feat: implement dark mode toggle</commit>
                <commit hash="ghi9012">feat: add JWT authentication</commit>
                <commit hash="jkl3456">test: add auth tests</commit>
                <commit hash="mno7890">style: update dark mode colors</commit>
            </commits>
        </initial_state>

        <workflow_execution>
            <step phase="initialization">
                <execute_command>git status</execute_command>
                <output>On branch feature/mixed-work, nothing to commit, working tree clean</output>
            </step>

            <step phase="commit_retrieval">
                <execute_command>git log main..HEAD --pretty=format:"%H|%s|%b" --reverse</execute_command>
                <output><![CDATA[
abc1234|feat: add user login form|
def5678|feat: implement dark mode toggle|
ghi9012|feat: add JWT authentication|Builds on login form
jkl3456|test: add auth tests|
mno7890|style: update dark mode colors|
        ]]></output>
            </step>

            <step phase="commit_analysis">
                <for_each_commit>
                    <execute_command>git show --name-only --pretty=format: abc1234</execute_command>
                    <output>src/components/LoginForm.tsx</output>
                </for_each_commit>
                <analysis>
                    Group 1: abc1234, ghi9012, jkl3456 (authentication feature)
                    Group 2: def5678, mno7890 (dark mode feature)
                </analysis>
            </step>

            <step phase="plan_presentation">
                <output><![CDATA[
## Branching Plan

Found 5 unmerged commits to organize into 2 branches:

### Branch 1: alexmandrik/feat/user-authentication
**Commits:**
- abc1234 feat: add user login form
- ghi9012 feat: add JWT authentication
- jkl3456 test: add auth tests

**Rationale:** These commits work together to implement user authentication

### Branch 2: alexmandrik/feat/dark-mode
**Commits:**
- def5678 feat: implement dark mode toggle
- mno7890 style: update dark mode colors

**Rationale:** These commits implement dark mode functionality
        ]]></output>
            </step>

            <step phase="confirmation">
                <ask_followup_question>
                    <question>Ready to create 2 branches and organize 5 commits?</question>
                    <user_response>Yes, proceed with the plan</user_response>
                </ask_followup_question>
            </step>

            <step phase="branch_1_creation">
                <execute_command>git checkout main</execute_command>
                <execute_command>git pull origin main</execute_command>
                <execute_command>git checkout -b alexmandrik/feat/user-authentication</execute_command>
                <execute_command>git cherry-pick abc1234</execute_command>
                <execute_command>git cherry-pick ghi9012</execute_command>
                <execute_command>git cherry-pick jkl3456</execute_command>
                <execute_command>git push -u origin alexmandrik/feat/user-authentication</execute_command>
            </step>

            <step phase="pr_creation_1">
                <new_task>
                    <mode>pr-creator</mode>
                    <message>Create a PR for branch alexmandrik/feat/user-authentication to merge
                        into main.</message>
                </new_task>
                <pr_result>https://github.com/user/repo/pull/101</pr_result>
            </step>

            <step phase="wait_for_merge_1">
                <ask_followup_question>
                    <question>PR created at https://github.com/user/repo/pull/101. Has it been
                        merged?</question>
                    <user_response>Yes, PR is merged - continue to next branch</user_response>
                </ask_followup_question>
            </step>

            <step phase="branch_2_creation">
                <execute_command>git checkout main</execute_command>
                <execute_command>git pull origin main</execute_command>
                <execute_command>git checkout -b alexmandrik/feat/dark-mode</execute_command>
                <execute_command>git cherry-pick def5678</execute_command>
                <execute_command>git cherry-pick mno7890</execute_command>
                <execute_command>git push -u origin alexmandrik/feat/dark-mode</execute_command>
            </step>

            <step phase="pr_creation_2">
                <new_task>
                    <mode>pr-creator</mode>
                    <message>Create a PR for branch alexmandrik/feat/dark-mode to merge into main.</message>
                </new_task>
                <pr_result>https://github.com/user/repo/pull/102</pr_result>
            </step>

            <step phase="wait_for_merge_2">
                <ask_followup_question>
                    <question>PR created at https://github.com/user/repo/pull/102. Has it been
                        merged?</question>
                    <user_response>Yes, PR is merged - continue to next branch</user_response>
                </ask_followup_question>
            </step>

            <step phase="completion">
                <execute_command>git checkout main</execute_command>
                <execute_command>git pull origin main</execute_command>
                <attempt_completion>
                    Successfully organized 5 commits into 2 branches:

                    1. alexmandrik/feat/user-authentication (PR #101 - merged)
                    - 3 commits related to user authentication

                    2. alexmandrik/feat/dark-mode (PR #102 - merged)
                    - 2 commits for dark mode feature

                    All branches have been created, PRs merged, and main branch is up to date.
                </attempt_completion>
            </step>
        </workflow_execution>
    </example>

    <example name="mixed_types_cleanup">
        <scenario>
            A developer has made various commits including features, fixes, and documentation
            updates
            that need to be organized into separate PRs for easier review.
        </scenario>

        <initial_state>
            <current_branch>dev/cleanup</current_branch>
            <commits>
                <commit hash="a1b2c3d">feat: add search functionality</commit>
                <commit hash="e4f5g6h">fix: correct timezone bug in datepicker</commit>
                <commit hash="i7j8k9l">docs: update README with new features</commit>
                <commit hash="m0n1o2p">feat: implement autocomplete for search</commit>
                <commit hash="q3r4s5t">fix: handle null values in search</commit>
                <commit hash="u6v7w8x">chore: update dependencies</commit>
            </commits>
        </initial_state>

        <analysis_and_grouping>
            <group number="1" type="feat">
                <branch_name>alexmandrik/feat/search-functionality</branch_name>
                <commits>
                    <commit>a1b2c3d feat: add search functionality</commit>
                    <commit>m0n1o2p feat: implement autocomplete for search</commit>
                    <commit>q3r4s5t fix: handle null values in search</commit>
                </commits>
                <rationale>All three relate to search feature implementation and fixes</rationale>
            </group>

            <group number="2" type="fix">
                <branch_name>alexmandrik/fix/timezone-datepicker</branch_name>
                <commits>
                    <commit>e4f5g6h fix: correct timezone bug in datepicker</commit>
                </commits>
                <rationale>Standalone bug fix unrelated to other changes</rationale>
            </group>

            <group number="3" type="docs">
                <branch_name>alexmandrik/docs/readme-updates</branch_name>
                <commits>
                    <commit>i7j8k9l docs: update README with new features</commit>
                </commits>
                <rationale>Documentation update</rationale>
            </group>

            <group number="4" type="chore">
                <branch_name>alexmandrik/chore/dependency-updates</branch_name>
                <commits>
                    <commit>u6v7w8x chore: update dependencies</commit>
                </commits>
                <rationale>Maintenance task</rationale>
            </group>
        </analysis_and_grouping>

        <key_points>
            <point>Commits are grouped by logical purpose, not just type</point>
            <point>Search feature includes a fix (q3r4s5t) because it's part of the feature
                completion</point>
            <point>Four separate PRs allow independent review and merging</point>
            <point>Each branch can be deployed independently</point>
        </key_points>
    </example>

    <example name="conflict_resolution">
        <scenario>
            During cherry-picking, a conflict occurs because the same file was modified in main
            after the original commits were made.
        </scenario>

        <workflow_at_conflict>
            <step>
                <execute_command>git cherry-pick abc1234</execute_command>
                <output><![CDATA[
error: could not apply abc1234... feat: add user service
hint: after resolving the conflicts, mark the corrected paths
hint: with 'git add <paths>' or 'git rm <paths>'
hint: and commit the result with 'git commit'
CONFLICT (content): Merge conflict in src/services/user.ts
        ]]></output>
            </step>

            <step>
                <execute_command>git status</execute_command>
                <output><![CDATA[
On branch alexmandrik/feat/user-service
You are currently cherry-picking commit abc1234.

Unmerged paths:
  both modified:   src/services/user.ts
        ]]></output>
            </step>

            <step>
                <ask_followup_question>
                    <question>
                        Cherry-pick conflicts detected in src/services/user.ts. How should we
                        proceed?
                    </question>
                    <follow_up>
                        <option>Skip this commit and continue</option>
                        <option>Abort this branch group</option>
                        <option>Pause - I'll resolve manually</option>
                    </follow_up>
                </ask_followup_question>
            </step>

            <resolution_option_1>
                <user_choice>Skip this commit and continue</user_choice>
                <action>
                    <execute_command>git cherry-pick --abort</execute_command>
                    <note>Skip abc1234, continue with next commit in group</note>
                    <inform_user>Skipped abc1234 due to conflicts. You may need to apply this change
                        manually later.</inform_user>
                </action>
            </resolution_option_1>

            <resolution_option_2>
                <user_choice>Pause - I'll resolve manually</user_choice>
                <action>
                    <inform_user>
                        Please resolve conflicts in src/services/user.ts, then run:
                        git add src/services/user.ts
                        git cherry-pick --continue

                        Let me know when ready to continue.
                    </inform_user>
                    <wait_for_user_confirmation>User resolves and confirms</wait_for_user_confirmation>
                    <execute_command>git cherry-pick --continue</execute_command>
                    <continue_workflow>Proceed with next commit in group</continue_workflow>
                </action>
            </resolution_option_2>

            <resolution_option_3>
                <user_choice>Abort this branch group</user_choice>
                <action>
                    <execute_command>git cherry-pick --abort</execute_command>
                    <execute_command>git checkout main</execute_command>
                    <execute_command>git branch -D alexmandrik/feat/user-service</execute_command>
                    <note>Skip entire branch group, move to next group in plan</note>
                    <inform_user>Aborted branch group due to conflicts. Moving to next branch.</inform_user>
                </action>
            </resolution_option_3>
        </workflow_at_conflict>
    </example>

    <example name="no_commits_to_organize">
        <scenario>
            User runs the mode but their branch is already up to date with main.
        </scenario>

        <workflow_execution>
            <step>
                <execute_command>git log main..HEAD --oneline</execute_command>
                <output>(empty - no output)</output>
            </step>

            <step>
                <inform_user>
                    No unmerged commits found. Your current branch is up to date with main.
                </inform_user>
            </step>

            <step>
                <ask_followup_question>
                    <question>Would you like to check a different branch?</question>
                    <follow_up>
                        <option>Yes, let me switch branches</option>
                        <option>No, I'm done</option>
                    </follow_up>
                </ask_followup_question>
            </step>
        </workflow_execution>
    </example>

    <example name="dependency_chain_grouping">
        <scenario>
            Commits form a dependency chain where each builds on the previous.
            They must stay together in one branch.
        </scenario>

        <commits>
            <commit hash="aaa1111">feat: add database connection module</commit>
            <commit hash="bbb2222">feat: create user repository using db connection</commit>
            <commit hash="ccc3333">feat: add user service layer using repository</commit>
            <commit hash="ddd4444">feat: create user API endpoints using service</commit>
            <commit hash="eee5555">test: add integration tests for user API</commit>
        </commits>

        <analysis>
            All commits are part of a dependency chain:
            - bbb2222 depends on aaa1111 (uses db connection)
            - ccc3333 depends on bbb2222 (uses repository)
            - ddd4444 depends on ccc3333 (uses service)
            - eee5555 tests ddd4444 (tests endpoints)

            Cannot be split - must stay together
        </analysis>

        <grouping>
            <single_branch>
                <name>alexmandrik/feat/user-data-layer</name>
                <all_commits>aaa1111, bbb2222, ccc3333, ddd4444, eee5555</all_commits>
                <rationale>Sequential dependency chain forming complete feature</rationale>
            </single_branch>
        </grouping>

        <workflow>
            <plan_presentation>
                ## Branching Plan

                Found 5 unmerged commits to organize into 1 branch:

                ### Branch 1: alexmandrik/feat/user-data-layer
                **Commits:**
                - aaa1111 feat: add database connection module
                - bbb2222 feat: create user repository using db connection
                - ccc3333 feat: add user service layer using repository
                - ddd4444 feat: create user API endpoints using service
                - eee5555 test: add integration tests for user API

                **Rationale:** These commits form a sequential dependency chain where each builds
                on the previous. They implement a complete user data layer from database to API.
            </plan_presentation>
        </workflow>
    </example>

    <example name="user_modifies_plan">
        <scenario>
            User reviews the generated plan and requests modifications before proceeding.
        </scenario>

        <initial_plan>
            <branch>alexmandrik/feat/dashboard-widgets</branch>
            <commits>
                <commit>Add chart widget</commit>
                <commit>Add table widget</commit>
                <commit>Add map widget</commit>
            </commits>
        </initial_plan>

        <confirmation_step>
            <ask_followup_question>
                <question>Ready to create 1 branch with 3 commits?</question>
                <user_response>No, let me review and adjust</user_response>
            </ask_followup_question>
        </confirmation_step>

        <user_feedback>
            User requests: "Please split the map widget into a separate branch -
            it's experimental and I don't want to hold up the other widgets."
        </user_feedback>

        <revised_plan>
            <branch number="1">
                <name>alexmandrik/feat/dashboard-basic-widgets</name>
                <commits>
                    <commit>Add chart widget</commit>
                    <commit>Add table widget</commit>
                </commits>
            </branch>
            <branch number="2">
                <name>alexmandrik/feat/map-widget-experimental</name>
                <commits>
                    <commit>Add map widget</commit>
                </commits>
            </branch>
        </revised_plan>

        <re_confirmation>
            <ask_followup_question>
                <question>Ready to create 2 branches as revised?</question>
                <user_response>Yes, proceed with the plan</user_response>
            </ask_followup_question>
        </re_confirmation>

        <note>
            Mode should be flexible and allow user to adjust grouping before execution.
            Re-present the plan after modifications for confirmation.
        </note>
    </example>

    <example name="chronological_branch_ordering">
        <scenario>
            Demonstrates the critical requirement to process branch groups in chronological order
            based on the oldest commit in each group, using the real-world case from the user's
            feedback.
        </scenario>

        <initial_state>
            <current_branch>feature/mixed-commits</current_branch>
            <commits_with_timestamps>
                <commit hash="623c9c0" timestamp="1707000000" date="2024-02-04 10:00:00">
                    feat(modes): add viral LinkedIn article architect mode
                </commit>
                <commit hash="eba0af8" timestamp="1707050000" date="2024-02-04 23:53:20">
                    feat: add UTK Turfgrass FIFA World Cup 26 project
                </commit>
                <commit hash="56ff816" timestamp="1707100000" date="2024-02-05 13:46:40">
                    docs(content-generator): add project page generation workflow
                </commit>
            </commits_with_timestamps>
        </initial_state>

        <commit_retrieval>
            <execute_command>git log main..HEAD --pretty=format:"%H|%at|%s|%b" --reverse</execute_command>
            <output><![CDATA[
623c9c0|1707000000|feat(modes): add viral LinkedIn article architect mode|
eba0af8|1707050000|feat: add UTK Turfgrass FIFA World Cup 26 project|
56ff816|1707100000|docs(content-generator): add project page generation workflow|
        ]]></output>
        </commit_retrieval>

        <grouping_analysis>
            <group id="1" name="UTK Turfgrass Project">
                <commits>eba0af8</commits>
                <oldest_commit_timestamp>1707050000</oldest_commit_timestamp>
                <files>
                    - projects/utk-turfgrass.htm
                    - linkedin-projects/utk-turfgrass.txt
                    - 12 screenshot images
                </files>
            </group>
            <group id="2" name="Documentation Update">
                <commits>56ff816</commits>
                <oldest_commit_timestamp>1707100000</oldest_commit_timestamp>
                <files>
                    - .roo/rules-content-generator/project-page-generation-workflow.xml
                </files>
            </group>
            <group id="3" name="LinkedIn Mode">
                <commits>623c9c0</commits>
                <oldest_commit_timestamp>1707000000</oldest_commit_timestamp>
                <files>
                    - .roo/rules-linkedin-article-architect/*.xml
                    - .roomodes
                </files>
            </group>
        </grouping_analysis>

        <chronological_sorting>
            <explanation>
                Before presenting the plan, sort groups by oldest commit timestamp:
                - Group 3 (LinkedIn Mode): oldest = 1707000000 (Feb 4, 10:00)
                - Group 1 (UTK Project): oldest = 1707050000 (Feb 4, 23:53)
                - Group 2 (Documentation): oldest = 1707100000 (Feb 5, 13:46)
            </explanation>
        </chronological_sorting>

        <correct_plan_presentation>
            <output><![CDATA[
## Branching Plan

Found 3 unmerged commits to organize into 3 branches:

### Branch 1: alexmandrik/feat/linkedin-article-architect-mode
**Commits:**
- 623c9c0 feat(modes): add viral LinkedIn article architect mode

**Files changed:**
- .roo/rules-linkedin-article-architect/1_workflow.xml
- .roo/rules-linkedin-article-architect/2_hook_formulas.xml
- .roo/rules-linkedin-article-architect/3_outline_templates.xml
- .roo/rules-linkedin-article-architect/4_engagement_techniques.xml
- .roo/rules-linkedin-article-architect/5_examples.xml
- .roomodes

**Rationale:** New custom mode for creating viral LinkedIn articles, including comprehensive rule files and mode configuration.

**Chronology:** Contains the OLDEST commit (Feb 4, 10:00) - must be processed first

### Branch 2: alexmandrik/feat/utk-turfgrass-project
**Commits:**
- eba0af8 feat: add UTK Turfgrass FIFA World Cup 26 project

**Files changed:**
- projects/utk-turfgrass.htm
- linkedin-projects/utk-turfgrass.txt
- 12 screenshot images in projects/images/utk-turfgrass/

**Rationale:** Standalone feature adding a new project page to the portfolio with associated images and LinkedIn content.

**Chronology:** Contains the second oldest commit (Feb 4, 23:53)

### Branch 3: alexmandrik/docs/content-generator-workflow
**Commits:**
- 56ff816 docs(content-generator): add project page generation workflow

**Files changed:**
- .roo/rules-content-generator/project-page-generation-workflow.xml

**Rationale:** Documentation addition for the content generator workflow, defining the process for generating project pages.

**Chronology:** Contains the newest commit (Feb 5, 13:46) - processed last
        ]]></output>
        </correct_plan_presentation>

        <incorrect_example>
            <wrong_approach>
                <!-- DO NOT DO THIS --> Presenting branches in arbitrary order without considering chronology:
                Branch 1: UTK Project (timestamp: 1707050000) Branch 2: Documentation (timestamp:
                1707100000) Branch 3: LinkedIn Mode (timestamp: 1707000000) <!-- WRONG - oldest
                should be first! -->
            </wrong_approach>
            <why_wrong>
                This violates chronological ordering. The LinkedIn Mode has the oldest commit
                (623c9c0)
                and MUST be processed as Branch 1, not Branch 3.
            </why_wrong>
        </incorrect_example>

        <execution_order>
            <step>Process Branch 1 (LinkedIn Mode - oldest commit 623c9c0)</step>
            <step>Wait for PR merge and update main</step>
            <step>Process Branch 2 (UTK Project - middle commit eba0af8)</step>
            <step>Wait for PR merge and update main</step>
            <step>Process Branch 3 (Documentation - newest commit 56ff816)</step>
            <step>Wait for PR merge and update main</step>
        </execution_order>

        <critical_principle>
            ALWAYS sort branch groups by their oldest commit's timestamp before presenting the plan.
            The branch containing the chronologically oldest commit must always be "Branch 1",
            regardless of content, file types, or logical grouping.
        </critical_principle>
    </example>

    <key_takeaways>
        <takeaway>Always start from updated main branch for each new branch</takeaway>
        <takeaway>Cherry-pick commits in chronological order within groups</takeaway>
        <takeaway>CRITICAL: Order branch groups by oldest commit timestamp (oldest first)</takeaway>
        <takeaway>Capture commit timestamps using %at in git log for accurate sorting</takeaway>
        <takeaway>Handle conflicts gracefully with user input</takeaway>
        <takeaway>Wait for user confirmation after each PR is created</takeaway>
        <takeaway>Update main after each merge before creating next branch</takeaway>
        <takeaway>Group commits by logical purpose, not just type or file proximity</takeaway>
        <takeaway>Allow user to modify the plan before execution</takeaway>
        <takeaway>Provide clear, structured output at each phase</takeaway>
    </key_takeaways>
</examples>